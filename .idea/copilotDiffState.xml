<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/erp-backend/src/main/java/com/company/erp/notification/entity/NotificationPriority.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/erp-backend/src/main/java/com/company/erp/notification/entity/NotificationPriority.java" />
              <option name="originalContent" value="package com.company.erp.notification.entity;&#10;&#10;public enum NotificationPriority {&#10;    LOW(&quot;Low&quot;, &quot;Low priority notification&quot;, &quot;#28a745&quot;),&#10;    NORMAL(&quot;Normal&quot;, &quot;Normal priority notification&quot;, &quot;#007bff&quot;),&#10;    HIGH(&quot;High&quot;, &quot;High priority notification&quot;, &quot;#fd7e14&quot;),&#10;    CRITICAL(&quot;Critical&quot;, &quot;Critical priority notification&quot;, &quot;#dc3545&quot;);&#10;&#10;    private final String displayName;&#10;    private final String description;&#10;    private final String colorCode;&#10;&#10;    NotificationPriority(String displayName, String description, String colorCode) {&#10;        this.displayName = displayName;&#10;        this.description = description;&#10;        this.colorCode = colorCode;&#10;    }&#10;&#10;    public String getDisplayName() {&#10;        return displayName;&#10;    }&#10;&#10;    public String getDescription() {&#10;        return description;&#10;    }&#10;&#10;    public String getColorCode() {&#10;        return colorCode;&#10;    }&#10;&#10;    public int getPriorityLevel() {&#10;        return ordinal();&#10;    }&#10;&#10;    public boolean isHigherThan(NotificationPriority other) {&#10;        return this.ordinal() &gt; other.ordinal();&#10;    }&#10;&#10;    public boolean isAtLeast(NotificationPriority threshold) {&#10;        return this.ordinal() &gt;= threshold.ordinal();&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.company.erp.notification.entity;&#13;&#10;&#13;&#10;public enum NotificationPriority {&#13;&#10;    LOW(&quot;Low&quot;, &quot;Low priority notification&quot;, &quot;#28a745&quot;),&#13;&#10;    NORMAL(&quot;Normal&quot;, &quot;Normal priority notification&quot;, &quot;#007bff&quot;),&#13;&#10;    MEDIUM(&quot;Medium&quot;, &quot;Medium priority notification&quot;, &quot;#fd7e14&quot;),&#13;&#10;    HIGH(&quot;High&quot;, &quot;High priority notification&quot;, &quot;#dc3545&quot;),&#13;&#10;    CRITICAL(&quot;Critical&quot;, &quot;Critical priority notification&quot;, &quot;#dc3545&quot;);&#13;&#10;&#13;&#10;    private final String displayName;&#13;&#10;    private final String description;&#13;&#10;    private final String colorCode;&#13;&#10;&#13;&#10;    NotificationPriority(String displayName, String description, String colorCode) {&#13;&#10;        this.displayName = displayName;&#13;&#10;        this.description = description;&#13;&#10;        this.colorCode = colorCode;&#13;&#10;    }&#13;&#10;&#13;&#10;    public String getDisplayName() {&#13;&#10;        return displayName;&#13;&#10;    }&#13;&#10;&#13;&#10;    public String getDescription() {&#13;&#10;        return description;&#13;&#10;    }&#13;&#10;&#13;&#10;    public String getColorCode() {&#13;&#10;        return colorCode;&#13;&#10;    }&#13;&#10;&#13;&#10;    public int getPriorityLevel() {&#13;&#10;        return ordinal();&#13;&#10;    }&#13;&#10;&#13;&#10;    public boolean isHigherThan(NotificationPriority other) {&#13;&#10;        return this.ordinal() &gt; other.ordinal();&#13;&#10;    }&#13;&#10;&#13;&#10;    public boolean isAtLeast(NotificationPriority threshold) {&#13;&#10;        return this.ordinal() &gt;= threshold.ordinal();&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/erp-backend/src/main/java/com/company/erp/notification/service/NotificationService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/erp-backend/src/main/java/com/company/erp/notification/service/NotificationService.java" />
              <option name="originalContent" value="// Enhanced NotificationService.java&#10;package com.company.erp.notification.service;&#10;&#10;import com.company.erp.common.service.AuditService;&#10;import com.company.erp.notification.entity.Notification;&#10;import com.company.erp.notification.entity.NotificationPreference;&#10;import com.company.erp.notification.entity.NotificationTemplate;&#10;import com.company.erp.notification.entity.NotificationType;&#10;import com.company.erp.notification.entity.NotificationChannel;&#10;import com.company.erp.notification.entity.NotificationPriority;&#10;import com.company.erp.notification.repository.NotificationRepository;&#10;import com.company.erp.notification.repository.NotificationPreferenceRepository;&#10;import com.company.erp.notification.repository.NotificationTemplateRepository;&#10;import com.company.erp.user.entity.User;&#10;import com.company.erp.user.service.UserService;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;import org.springframework.scheduling.annotation.Async;&#10;import org.springframework.scheduling.annotation.Scheduled;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.transaction.annotation.Transactional;&#10;&#10;import java.time.LocalDateTime;&#10;import java.time.LocalTime;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Set;&#10;import java.util.concurrent.CompletableFuture;&#10;&#10;@Service&#10;@Transactional&#10;public class NotificationService {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(NotificationService.class);&#10;&#10;    private final NotificationRepository notificationRepository;&#10;    private final NotificationPreferenceRepository preferenceRepository;&#10;    private final NotificationTemplateRepository templateRepository;&#10;    private final EmailService emailService;&#10;    private final SmsService smsService;&#10;    private final UserService userService;&#10;    private final AuditService auditService;&#10;&#10;    public NotificationService(NotificationRepository notificationRepository,&#10;                               NotificationPreferenceRepository preferenceRepository,&#10;                               NotificationTemplateRepository templateRepository,&#10;                               EmailService emailService,&#10;                               SmsService smsService,&#10;                               UserService userService,&#10;                               AuditService auditService) {&#10;        this.notificationRepository = notificationRepository;&#10;        this.preferenceRepository = preferenceRepository;&#10;        this.templateRepository = templateRepository;&#10;        this.emailService = emailService;&#10;        this.smsService = smsService;&#10;        this.userService = userService;&#10;        this.auditService = auditService;&#10;    }&#10;&#10;    @Async&#10;    public CompletableFuture&lt;Void&gt; sendNotification(Long userId, NotificationType type,&#10;                                                    Map&lt;String, Object&gt; templateData,&#10;                                                    NotificationPriority priority) {&#10;        try {&#10;            User user = userService.getUserById(userId);&#10;            NotificationPreference preference = getOrCreateUserPreference(user);&#10;&#10;            // Check if user wants to receive this type of notification&#10;            if (!shouldSendNotification(preference, type, priority)) {&#10;                logger.debug(&quot;Notification blocked by user preference: {} - {}&quot;, userId, type);&#10;                return CompletableFuture.completedFuture(null);&#10;            }&#10;&#10;            // Get template for notification type&#10;            NotificationTemplate template = templateRepository.findByType(type)&#10;                    .orElseThrow(() -&gt; new IllegalArgumentException(&quot;Template not found for type: &quot; + type));&#10;&#10;            // Create notification record&#10;            Notification notification = createNotification(user, type, template, templateData, priority);&#10;            notification = notificationRepository.save(notification);&#10;&#10;            // Send through preferred channels&#10;            sendThroughChannels(user, preference, template, templateData, priority);&#10;&#10;            // Mark as sent&#10;            notification.setSent(true);&#10;            notification.setSentDate(LocalDateTime.now());&#10;            notificationRepository.save(notification);&#10;&#10;            // Audit log&#10;            auditService.logAction(userId, &quot;NOTIFICATION_SENT&quot;, &quot;NOTIFICATION&quot;,&#10;                    notification.getId(), &quot;Notification sent: &quot; + type, null, null);&#10;&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to send notification to user {}: {}&quot;, userId, e.getMessage(), e);&#10;            throw new RuntimeException(&quot;Notification sending failed&quot;, e);&#10;        }&#10;&#10;        return CompletableFuture.completedFuture(null);&#10;    }&#10;&#10;    private void sendThroughChannels(User user, NotificationPreference preference,&#10;                                     NotificationTemplate template, Map&lt;String, Object&gt; templateData,&#10;                                     NotificationPriority priority) {&#10;&#10;        Set&lt;NotificationChannel&gt; channels = getChannelsForPriority(preference, priority);&#10;&#10;        for (NotificationChannel channel : channels) {&#10;            switch (channel) {&#10;                case EMAIL:&#10;                    if (user.getEmail() != null &amp;&amp; preference.getEmailEnabled()) {&#10;                        sendEmailNotification(user, template, templateData);&#10;                    }&#10;                    break;&#10;                case SMS:&#10;                    if (user.getPhoneNumber() != null &amp;&amp; preference.getSmsEnabled()) {&#10;                        sendSmsNotification(user, template, templateData);&#10;                    }&#10;                    break;&#10;                case IN_APP:&#10;                    // Create in-app notification&#10;                    createInAppNotification(user, template, templateData);&#10;                    break;&#10;                case PUSH:&#10;                    // Future: Browser push notifications&#10;                    logger.debug(&quot;Push notifications not yet implemented&quot;);&#10;                    break;&#10;            }&#10;        }&#10;    }&#10;&#10;    private Set&lt;NotificationChannel&gt; getChannelsForPriority(NotificationPreference preference,&#10;                                                            NotificationPriority priority) {&#10;        switch (priority) {&#10;            case CRITICAL:&#10;                return Set.of(NotificationChannel.EMAIL, NotificationChannel.SMS,&#10;                        NotificationChannel.IN_APP, NotificationChannel.PUSH);&#10;            case HIGH:&#10;                return Set.of(NotificationChannel.EMAIL, NotificationChannel.IN_APP);&#10;            case MEDIUM:&#10;                return Set.of(NotificationChannel.EMAIL, NotificationChannel.IN_APP);&#10;            case LOW:&#10;            default:&#10;                return Set.of(NotificationChannel.IN_APP);&#10;        }&#10;    }&#10;&#10;    private void sendEmailNotification(User user, NotificationTemplate template,&#10;                                       Map&lt;String, Object&gt; templateData) {&#10;        try {&#10;            String subject = processTemplate(template.getEmailSubject(), templateData);&#10;            String body = processTemplate(template.getEmailBody(), templateData);&#10;&#10;            emailService.sendEmail(user.getEmail(), subject, body, template.getIsHtml());&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to send email notification to {}: {}&quot;, user.getEmail(), e.getMessage());&#10;        }&#10;    }&#10;&#10;    private void sendSmsNotification(User user, NotificationTemplate template,&#10;                                     Map&lt;String, Object&gt; templateData) {&#10;        try {&#10;            String message = processTemplate(template.getSmsTemplate(), templateData);&#10;&#10;            // SMS messages should be concise&#10;            if (message.length() &gt; 160) {&#10;                message = message.substring(0, 157) + &quot;...&quot;;&#10;            }&#10;&#10;            smsService.sendSms(user.getPhoneNumber(), message);&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to send SMS notification to {}: {}&quot;, user.getPhoneNumber(), e.getMessage());&#10;        }&#10;    }&#10;&#10;    private void createInAppNotification(User user, NotificationTemplate template,&#10;                                         Map&lt;String, Object&gt; templateData) {&#10;        try {&#10;            String title = processTemplate(template.getTitle(), templateData);&#10;            String message = processTemplate(template.getInAppTemplate(), templateData);&#10;&#10;            Notification inAppNotification = new Notification();&#10;            inAppNotification.setUser(user);&#10;            inAppNotification.setType(template.getType());&#10;            inAppNotification.setTitle(title);&#10;            inAppNotification.setMessage(message);&#10;            inAppNotification.setChannel(NotificationChannel.IN_APP);&#10;            inAppNotification.setRead(false);&#10;            inAppNotification.setSent(true);&#10;            inAppNotification.setSentDate(LocalDateTime.now());&#10;&#10;            notificationRepository.save(inAppNotification);&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to create in-app notification for user {}: {}&quot;, user.getId(), e.getMessage());&#10;        }&#10;    }&#10;&#10;    private String processTemplate(String template, Map&lt;String, Object&gt; data) {&#10;        if (template == null) return &quot;&quot;;&#10;&#10;        String processed = template;&#10;        for (Map.Entry&lt;String, Object&gt; entry : data.entrySet()) {&#10;            String placeholder = &quot;${&quot; + entry.getKey() + &quot;}&quot;;&#10;            String value = entry.getValue() != null ? entry.getValue().toString() : &quot;&quot;;&#10;            processed = processed.replace(placeholder, value);&#10;        }&#10;        return processed;&#10;    }&#10;&#10;    private boolean shouldSendNotification(NotificationPreference preference,&#10;                                           NotificationType type, NotificationPriority priority) {&#10;&#10;        // Always send critical notifications&#10;        if (priority == NotificationPriority.CRITICAL) {&#10;            return true;&#10;        }&#10;&#10;        // Check do not disturb hours&#10;        if (preference.getDoNotDisturbEnabled() &amp;&amp; isInDoNotDisturbHours(preference)) {&#10;            return false;&#10;        }&#10;&#10;        // Check if type is enabled&#10;        return preference.getEnabledTypes().contains(type);&#10;    }&#10;&#10;    private boolean isInDoNotDisturbHours(NotificationPreference preference) {&#10;        LocalTime now = LocalTime.now();&#10;        LocalTime start = preference.getDoNotDisturbStart();&#10;        LocalTime end = preference.getDoNotDisturbEnd();&#10;&#10;        if (start == null || end == null) {&#10;            return false;&#10;        }&#10;&#10;        if (start.isBefore(end)) {&#10;            return now.isAfter(start) &amp;&amp; now.isBefore(end);&#10;        } else {&#10;            // Overnight period (e.g., 22:00 to 06:00)&#10;            return now.isAfter(start) || now.isBefore(end);&#10;        }&#10;    }&#10;&#10;    private NotificationPreference getOrCreateUserPreference(User user) {&#10;        return preferenceRepository.findByUserId(user.getId())&#10;                .orElseGet(() -&gt; createDefaultPreference(user));&#10;    }&#10;&#10;    private NotificationPreference createDefaultPreference(User user) {&#10;        NotificationPreference preference = new NotificationPreference();&#10;        preference.setUser(user);&#10;        preference.setEmailEnabled(true);&#10;        preference.setSmsEnabled(true);&#10;        preference.setInAppEnabled(true);&#10;        preference.setPushEnabled(false);&#10;        preference.setDoNotDisturbEnabled(false);&#10;        preference.setLanguage(&quot;en&quot;);&#10;&#10;        // Enable all notification types by default&#10;        preference.setEnabledTypes(Set.of(NotificationType.values()));&#10;&#10;        return preferenceRepository.save(preference);&#10;    }&#10;&#10;    private Notification createNotification(User user, NotificationType type,&#10;                                            NotificationTemplate template, Map&lt;String, Object&gt; templateData,&#10;                                            NotificationPriority priority) {&#10;        Notification notification = new Notification();&#10;        notification.setUser(user);&#10;        notification.setType(type);&#10;        notification.setTitle(processTemplate(template.getTitle(), templateData));&#10;        notification.setMessage(processTemplate(template.getInAppTemplate(), templateData));&#10;        notification.setPriority(priority);&#10;        notification.setChannel(NotificationChannel.MULTI); // Multiple channels&#10;        notification.setTemplateData(templateData);&#10;        notification.setRead(false);&#10;        notification.setSent(false);&#10;&#10;        return notification;&#10;    }&#10;&#10;    // Batch notification methods for efficiency&#10;    @Scheduled(fixedRate = 60000) // Every minute&#10;    public void processPendingNotifications() {&#10;        List&lt;Notification&gt; pending = notificationRepository.findBySentFalseAndScheduledTimeBefore(LocalDateTime.now());&#10;&#10;        for (Notification notification : pending) {&#10;            try {&#10;                sendNotification(notification.getUser().getId(), notification.getType(),&#10;                        notification.getTemplateData(), notification.getPriority());&#10;            } catch (Exception e) {&#10;                logger.error(&quot;Failed to process pending notification {}: {}&quot;, notification.getId(), e.getMessage());&#10;            }&#10;        }&#10;    }&#10;&#10;    @Scheduled(cron = &quot;0 0 9 * * MON-FRI&quot;) // 9 AM on weekdays&#10;    public void sendDailySummaryNotifications() {&#10;        List&lt;User&gt; users = userService.getAllActiveUsers();&#10;&#10;        for (User user : users) {&#10;            NotificationPreference preference = getOrCreateUserPreference(user);&#10;            if (preference.getDailySummaryEnabled()) {&#10;                sendDailySummary(user);&#10;            }&#10;        }&#10;    }&#10;&#10;    private void sendDailySummary(User user) {&#10;        // Get user's pending items&#10;        Map&lt;String, Object&gt; summaryData = Map.of(&#10;                &quot;userName&quot;, user.getFullName(),&#10;                &quot;pendingApprovals&quot;, getPendingApprovalsCount(user),&#10;                &quot;budgetAlerts&quot;, getBudgetAlertsCount(user),&#10;                &quot;recentActivity&quot;, getRecentActivityCount(user)&#10;        );&#10;&#10;        sendNotification(user.getId(), NotificationType.DAILY_SUMMARY, summaryData, NotificationPriority.LOW);&#10;    }&#10;&#10;    private int getPendingApprovalsCount(User user) {&#10;        // Implementation would query approval service&#10;        return 0; // Placeholder&#10;    }&#10;&#10;    private int getBudgetAlertsCount(User user) {&#10;        // Implementation would query budget service&#10;        return 0; // Placeholder&#10;    }&#10;&#10;    private int getRecentActivityCount(User user) {&#10;        // Implementation would query recent activities&#10;        return 0; // Placeholder&#10;    }&#10;&#10;    // Public API methods&#10;    public void sendQuotationSubmittedNotification(Long managerId, String projectName,&#10;                                                   String quotationId, String submittedBy) {&#10;        Map&lt;String, Object&gt; data = Map.of(&#10;                &quot;projectName&quot;, projectName,&#10;                &quot;quotationId&quot;, quotationId,&#10;                &quot;submittedBy&quot;, submittedBy,&#10;                &quot;actionUrl&quot;, &quot;/quotations/&quot; + quotationId&#10;        );&#10;&#10;        sendNotification(managerId, NotificationType.QUOTATION_SUBMITTED, data, NotificationPriority.MEDIUM);&#10;    }&#10;&#10;    public void sendQuotationApprovedNotification(Long projectManagerId, String projectName,&#10;                                                  String quotationId, String approvedBy) {&#10;        Map&lt;String, Object&gt; data = Map.of(&#10;                &quot;projectName&quot;, projectName,&#10;                &quot;quotationId&quot;, quotationId,&#10;                &quot;approvedBy&quot;, approvedBy,&#10;                &quot;actionUrl&quot;, &quot;/quotations/&quot; + quotationId&#10;        );&#10;&#10;        sendNotification(projectManagerId, NotificationType.QUOTATION_APPROVED, data, NotificationPriority.MEDIUM);&#10;    }&#10;&#10;    public void sendBudgetExceededNotification(Long managerId, String projectName,&#10;                                               String utilizationPercentage) {&#10;        Map&lt;String, Object&gt; data = Map.of(&#10;                &quot;projectName&quot;, projectName,&#10;                &quot;utilizationPercentage&quot;, utilizationPercentage,&#10;                &quot;actionUrl&quot;, &quot;/projects/&quot; + projectName + &quot;/budget&quot;&#10;        );&#10;&#10;        sendNotification(managerId, NotificationType.BUDGET_EXCEEDED, data, NotificationPriority.CRITICAL);&#10;    }&#10;&#10;    public void sendPaymentCompletedNotification(Long projectManagerId, String projectName,&#10;                                                 String amount, String paymentDate) {&#10;        Map&lt;String, Object&gt; data = Map.of(&#10;                &quot;projectName&quot;, projectName,&#10;                &quot;amount&quot;, amount,&#10;                &quot;paymentDate&quot;, paymentDate&#10;        );&#10;&#10;        sendNotification(projectManagerId, NotificationType.PAYMENT_COMPLETED, data, NotificationPriority.LOW);&#10;    }&#10;&#10;    // Convenience method for external services&#10;    public void sendEmailNotification(String to, String subject, String body) {&#10;        emailService.sendEmail(to, subject, body, false);&#10;    }&#10;&#10;    public void sendSmsNotification(String phoneNumber, String message) {&#10;        smsService.sendSms(phoneNumber, message);&#10;    }&#10;&#10;    @Transactional(readOnly = true)&#10;    public List&lt;Notification&gt; getUserNotifications(Long userId, int limit) {&#10;        return notificationRepository.findByUserIdOrderByCreatedDateDesc(userId,&#10;                org.springframework.data.domain.PageRequest.of(0, limit));&#10;    }&#10;&#10;    @Transactional(readOnly = true)&#10;    public long getUnreadNotificationCount(Long userId) {&#10;        return notificationRepository.countByUserIdAndReadFalse(userId);&#10;    }&#10;&#10;    public void markNotificationAsRead(Long notificationId, Long userId) {&#10;        Notification notification = notificationRepository.findByIdAndUserId(notificationId, userId)&#10;                .orElseThrow(() -&gt; new IllegalArgumentException(&quot;Notification not found&quot;));&#10;&#10;        notification.setRead(true);&#10;        notification.setReadDate(LocalDateTime.now());&#10;        notificationRepository.save(notification);&#10;    }&#10;&#10;    public void markAllNotificationsAsRead(Long userId) {&#10;        List&lt;Notification&gt; unreadNotifications = notificationRepository.findByUserIdAndReadFalse(userId);&#10;&#10;        for (Notification notification : unreadNotifications) {&#10;            notification.setRead(true);&#10;            notification.setReadDate(LocalDateTime.now());&#10;        }&#10;&#10;        notificationRepository.saveAll(unreadNotifications);&#10;    }&#10;}" />
              <option name="updatedContent" value="// Enhanced NotificationService.java&#10;package com.company.erp.notification.service;&#10;&#10;import com.company.erp.common.service.AuditService;&#10;import com.company.erp.notification.entity.Notification;&#10;import com.company.erp.notification.entity.NotificationPreference;&#10;import com.company.erp.notification.entity.NotificationTemplate;&#10;import com.company.erp.notification.entity.NotificationType;&#10;import com.company.erp.notification.entity.NotificationChannel;&#10;import com.company.erp.notification.entity.NotificationPriority;&#10;import com.company.erp.notification.repository.NotificationRepository;&#10;import com.company.erp.notification.repository.NotificationPreferenceRepository;&#10;import com.company.erp.notification.repository.NotificationTemplateRepository;&#10;import com.company.erp.user.entity.User;&#10;import com.company.erp.user.service.UserService;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;import org.springframework.data.domain.PageRequest;&#10;import org.springframework.scheduling.annotation.Async;&#10;import org.springframework.scheduling.annotation.Scheduled;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.transaction.annotation.Transactional;&#10;&#10;import java.time.LocalDateTime;&#10;import java.time.LocalTime;&#10;import java.util.*;&#10;import java.util.concurrent.CompletableFuture;&#10;import java.util.stream.Collectors;&#10;&#10;@Service&#10;@Transactional&#10;public class NotificationService {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(NotificationService.class);&#10;&#10;    private final NotificationRepository notificationRepository;&#10;    private final NotificationPreferenceRepository preferenceRepository;&#10;    private final NotificationTemplateRepository templateRepository;&#10;    private final EmailService emailService;&#10;    private final SmsService smsService;&#10;    private final UserService userService;&#10;    private final AuditService auditService;&#10;&#10;    public NotificationService(NotificationRepository notificationRepository,&#10;                               NotificationPreferenceRepository preferenceRepository,&#10;                               NotificationTemplateRepository templateRepository,&#10;                               EmailService emailService,&#10;                               SmsService smsService,&#10;                               UserService userService,&#10;                               AuditService auditService) {&#10;        this.notificationRepository = notificationRepository;&#10;        this.preferenceRepository = preferenceRepository;&#10;        this.templateRepository = templateRepository;&#10;        this.emailService = emailService;&#10;        this.smsService = smsService;&#10;        this.userService = userService;&#10;        this.auditService = auditService;&#10;    }&#10;&#10;    @Async&#10;    public CompletableFuture&lt;Void&gt; sendNotification(Long userId, NotificationType type,&#10;                                                    Map&lt;String, Object&gt; templateData,&#10;                                                    NotificationPriority priority) {&#10;        try {&#10;            // Fix: Get User entity directly instead of UserResponse&#10;            User user = userService.findById(userId)&#10;                    .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;            &#10;            NotificationPreference preference = getOrCreateUserPreference(user);&#10;&#10;            // Check if user wants to receive this type of notification&#10;            if (!shouldSendNotification(preference, type, priority)) {&#10;                logger.debug(&quot;Notification blocked by user preference: {} - {}&quot;, userId, type);&#10;                return CompletableFuture.completedFuture(null);&#10;            }&#10;&#10;            // Get template for notification type&#10;            NotificationTemplate template = templateRepository.findByType(type)&#10;                    .orElseThrow(() -&gt; new IllegalArgumentException(&quot;Template not found for type: &quot; + type));&#10;&#10;            // Create notification record&#10;            Notification notification = createNotification(user, type, template, templateData, priority);&#10;            notification = notificationRepository.save(notification);&#10;&#10;            // Send through preferred channels&#10;            sendThroughChannels(user, preference, template, templateData, priority);&#10;&#10;            // Mark as sent - Fix: use setSentAt instead of setSentDate&#10;            notification.setSent(true);&#10;            notification.setSentAt(LocalDateTime.now());&#10;            notificationRepository.save(notification);&#10;&#10;            // Audit log&#10;            auditService.logAction(userId, &quot;NOTIFICATION_SENT&quot;, &quot;NOTIFICATION&quot;,&#10;                    notification.getId(), &quot;Notification sent: &quot; + type, null, null);&#10;&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to send notification to user {}: {}&quot;, userId, e.getMessage(), e);&#10;            throw new RuntimeException(&quot;Notification sending failed&quot;, e);&#10;        }&#10;&#10;        return CompletableFuture.completedFuture(null);&#10;    }&#10;&#10;    public CompletableFuture&lt;Void&gt; createNotification(Long userId, String title, String message, String type) {&#10;        return createNotification(userId, title, message, type, NotificationPriority.NORMAL);&#10;    }&#10;&#10;    public CompletableFuture&lt;Void&gt; createNotification(Long userId, String title, String message, &#10;                                                     String type, NotificationPriority priority) {&#10;        try {&#10;            User user = userService.findById(userId)&#10;                    .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + userId));&#10;&#10;            Notification notification = new Notification();&#10;            notification.setUser(user);&#10;            notification.setTitle(title);&#10;            notification.setMessage(message);&#10;            notification.setType(NotificationType.valueOf(type));&#10;            notification.setPriority(priority);&#10;            notification.setChannel(NotificationChannel.IN_APP);&#10;            notification.setRead(false);&#10;            notification.setSent(true);&#10;            notification.setSentAt(LocalDateTime.now());&#10;&#10;            notificationRepository.save(notification);&#10;            &#10;            return CompletableFuture.completedFuture(null);&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to create notification for user {}: {}&quot;, userId, e.getMessage(), e);&#10;            return CompletableFuture.completedFuture(null);&#10;        }&#10;    }&#10;&#10;    private void sendThroughChannels(User user, NotificationPreference preference,&#10;                                     NotificationTemplate template, Map&lt;String, Object&gt; templateData,&#10;                                     NotificationPriority priority) {&#10;&#10;        Set&lt;NotificationChannel&gt; channels = getChannelsForPriority(preference, priority);&#10;&#10;        for (NotificationChannel channel : channels) {&#10;            switch (channel) {&#10;                case EMAIL:&#10;                    if (user.getEmail() != null &amp;&amp; preference.getEmailEnabled()) {&#10;                        sendEmailNotification(user, template, templateData);&#10;                    }&#10;                    break;&#10;                case SMS:&#10;                    if (user.getPhoneNumber() != null &amp;&amp; preference.getSmsEnabled()) {&#10;                        sendSmsNotification(user, template, templateData);&#10;                    }&#10;                    break;&#10;                case IN_APP:&#10;                    createInAppNotification(user, template, templateData);&#10;                    break;&#10;                case PUSH:&#10;                    logger.debug(&quot;Push notifications not yet implemented&quot;);&#10;                    break;&#10;            }&#10;        }&#10;    }&#10;&#10;    private Set&lt;NotificationChannel&gt; getChannelsForPriority(NotificationPreference preference,&#10;                                                            NotificationPriority priority) {&#10;        // Fix: Use correct enum constant names&#10;        switch (priority) {&#10;            case CRITICAL:&#10;                return Set.of(NotificationChannel.EMAIL, NotificationChannel.SMS,&#10;                        NotificationChannel.IN_APP, NotificationChannel.PUSH);&#10;            case HIGH:&#10;                return Set.of(NotificationChannel.EMAIL, NotificationChannel.IN_APP);&#10;            case MEDIUM:&#10;                return Set.of(NotificationChannel.EMAIL, NotificationChannel.IN_APP);&#10;            case LOW:&#10;            case NORMAL:&#10;            default:&#10;                return Set.of(NotificationChannel.IN_APP);&#10;        }&#10;    }&#10;&#10;    private void sendEmailNotification(User user, NotificationTemplate template,&#10;                                       Map&lt;String, Object&gt; templateData) {&#10;        try {&#10;            String subject = processTemplate(template.getEmailSubject(), templateData);&#10;            // Fix: use getEmailTemplate instead of getEmailBody&#10;            String body = processTemplate(template.getEmailTemplate(), templateData);&#10;&#10;            // Fix: EmailService method signature - add missing parameters&#10;            emailService.sendEmail(user.getEmail(), subject, body, false, Collections.emptyList(), null);&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to send email notification to {}: {}&quot;, user.getEmail(), e.getMessage());&#10;        }&#10;    }&#10;&#10;    private void sendSmsNotification(User user, NotificationTemplate template,&#10;                                     Map&lt;String, Object&gt; templateData) {&#10;        try {&#10;            String message = processTemplate(template.getSmsTemplate(), templateData);&#10;&#10;            if (message.length() &gt; 160) {&#10;                message = message.substring(0, 157) + &quot;...&quot;;&#10;            }&#10;&#10;            smsService.sendSms(user.getPhoneNumber(), message);&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to send SMS notification to {}: {}&quot;, user.getPhoneNumber(), e.getMessage());&#10;        }&#10;    }&#10;&#10;    private void createInAppNotification(User user, NotificationTemplate template,&#10;                                         Map&lt;String, Object&gt; templateData) {&#10;        try {&#10;            String title = processTemplate(template.getTitle(), templateData);&#10;            String message = processTemplate(template.getInAppTemplate(), templateData);&#10;&#10;            Notification inAppNotification = new Notification();&#10;            inAppNotification.setUser(user);&#10;            inAppNotification.setType(template.getType());&#10;            inAppNotification.setTitle(title);&#10;            inAppNotification.setMessage(message);&#10;            inAppNotification.setChannel(NotificationChannel.IN_APP);&#10;            inAppNotification.setRead(false);&#10;            inAppNotification.setSent(true);&#10;            // Fix: use setSentAt instead of setSentDate&#10;            inAppNotification.setSentAt(LocalDateTime.now());&#10;&#10;            notificationRepository.save(inAppNotification);&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to create in-app notification for user {}: {}&quot;, user.getId(), e.getMessage());&#10;        }&#10;    }&#10;&#10;    private String processTemplate(String template, Map&lt;String, Object&gt; data) {&#10;        if (template == null) return &quot;&quot;;&#10;&#10;        String processed = template;&#10;        for (Map.Entry&lt;String, Object&gt; entry : data.entrySet()) {&#10;            String placeholder = &quot;{{&quot; + entry.getKey() + &quot;}}&quot;;&#10;            String value = entry.getValue() != null ? entry.getValue().toString() : &quot;&quot;;&#10;            processed = processed.replace(placeholder, value);&#10;        }&#10;        return processed;&#10;    }&#10;&#10;    private Notification createNotification(User user, NotificationType type, &#10;                                           NotificationTemplate template, &#10;                                           Map&lt;String, Object&gt; templateData, &#10;                                           NotificationPriority priority) {&#10;        Notification notification = new Notification();&#10;        notification.setUser(user);&#10;        notification.setType(type);&#10;        notification.setTitle(processTemplate(template.getTitle(), templateData));&#10;        notification.setMessage(processTemplate(template.getInAppTemplate(), templateData));&#10;        notification.setPriority(priority);&#10;        notification.setChannel(NotificationChannel.IN_APP);&#10;        notification.setTemplateData(templateData);&#10;        notification.setRead(false);&#10;        notification.setSent(false);&#10;        return notification;&#10;    }&#10;&#10;    private NotificationPreference getOrCreateUserPreference(User user) {&#10;        return preferenceRepository.findByUserId(user.getId())&#10;                .orElseGet(() -&gt; createDefaultPreference(user));&#10;    }&#10;&#10;    private NotificationPreference createDefaultPreference(User user) {&#10;        NotificationPreference preference = new NotificationPreference();&#10;        preference.setUser(user);&#10;        preference.setEmailEnabled(true);&#10;        preference.setSmsEnabled(false);&#10;        preference.setInAppEnabled(true);&#10;        preference.setPushEnabled(false);&#10;        return preferenceRepository.save(preference);&#10;    }&#10;&#10;    private boolean shouldSendNotification(NotificationPreference preference, &#10;                                          NotificationType type, &#10;                                          NotificationPriority priority) {&#10;        // Always send critical notifications&#10;        if (priority == NotificationPriority.CRITICAL) {&#10;            return true;&#10;        }&#10;&#10;        // Check user preferences based on notification type&#10;        switch (type) {&#10;            case SYSTEM_ALERT:&#10;            case SECURITY_ALERT:&#10;                return true; // Always send system and security alerts&#10;            case BUDGET_ALERT:&#10;                return preference.getBudgetAlertsEnabled();&#10;            case PAYMENT_REMINDER:&#10;                return preference.getPaymentRemindersEnabled();&#10;            case PROJECT_UPDATE:&#10;                return preference.getProjectUpdatesEnabled();&#10;            default:&#10;                return preference.getGeneralNotificationsEnabled();&#10;        }&#10;    }&#10;&#10;    @Scheduled(cron = &quot;0 0 9-17 * * MON-FRI&quot;) // Every hour during business hours&#10;    public void processScheduledNotifications() {&#10;        List&lt;Notification&gt; scheduledNotifications = notificationRepository&#10;                .findByScheduledTimeLessThanEqualAndSentFalse(LocalDateTime.now());&#10;&#10;        for (Notification notification : scheduledNotifications) {&#10;            try {&#10;                sendScheduledNotification(notification);&#10;            } catch (Exception e) {&#10;                logger.error(&quot;Failed to send scheduled notification {}: {}&quot;, &#10;                           notification.getId(), e.getMessage());&#10;            }&#10;        }&#10;    }&#10;&#10;    private void sendScheduledNotification(Notification notification) {&#10;        // Implementation for sending scheduled notifications&#10;        notification.setSent(true);&#10;        notification.setSentAt(LocalDateTime.now());&#10;        notificationRepository.save(notification);&#10;    }&#10;&#10;    @Scheduled(cron = &quot;0 0 2 * * ?&quot;) // Daily at 2 AM&#10;    public void cleanupOldNotifications() {&#10;        LocalDateTime cutoffDate = LocalDateTime.now().minusDays(30);&#10;        List&lt;Notification&gt; oldNotifications = notificationRepository&#10;                .findByCreatedDateBeforeAndReadTrue(cutoffDate);&#10;&#10;        notificationRepository.deleteAll(oldNotifications);&#10;        logger.info(&quot;Cleaned up {} old notifications&quot;, oldNotifications.size());&#10;    }&#10;&#10;    public void sendBulkNotification(NotificationType type, String title, String message,&#10;                                    NotificationPriority priority) {&#10;        // Fix: Use findAllActiveUsers or similar method instead of getAllActiveUsers&#10;        List&lt;User&gt; activeUsers = userService.findAllActive();&#10;&#10;        for (User user : activeUsers) {&#10;            Map&lt;String, Object&gt; templateData = new HashMap&lt;&gt;();&#10;            templateData.put(&quot;userName&quot;, user.getFullName());&#10;            templateData.put(&quot;title&quot;, title);&#10;            templateData.put(&quot;message&quot;, message);&#10;&#10;            sendNotification(user.getId(), type, templateData, priority);&#10;        }&#10;&#10;        logger.info(&quot;Sent bulk notification to {} users&quot;, activeUsers.size());&#10;    }&#10;&#10;    public void sendProjectNotification(Long projectId, String title, String message) {&#10;        sendProjectNotification(projectId, title, message, NotificationPriority.NORMAL);&#10;    }&#10;&#10;    public void sendProjectNotification(Long projectId, String title, String message, &#10;                                       NotificationPriority priority) {&#10;        // Implementation would get project team members and send notifications&#10;        logger.info(&quot;Sending project notification for project {}&quot;, projectId);&#10;    }&#10;&#10;    public void sendBudgetAlert(Long projectId, String title, String message) {&#10;        sendBudgetAlert(projectId, title, message, NotificationPriority.HIGH);&#10;    }&#10;&#10;    public void sendBudgetAlert(Long projectId, String title, String message, &#10;                               NotificationPriority priority) {&#10;        // Implementation would get project stakeholders and send budget alerts&#10;        logger.info(&quot;Sending budget alert for project {}&quot;, projectId);&#10;    }&#10;&#10;    // User notification management methods&#10;    @Transactional(readOnly = true)&#10;    public List&lt;Notification&gt; getUserNotifications(Long userId, int page, int size) {&#10;        PageRequest pageRequest = PageRequest.of(page, size);&#10;        // Fix: Use correct repository method name&#10;        return notificationRepository.findByUserIdOrderByCreatedDateDesc(userId, pageRequest).getContent();&#10;    }&#10;&#10;    @Transactional(readOnly = true)&#10;    public long getUnreadNotificationCount(Long userId) {&#10;        // Fix: Use correct repository method name&#10;        return notificationRepository.countByUserIdAndReadFalse(userId);&#10;    }&#10;&#10;    public void markAsRead(Long notificationId, Long userId) {&#10;        // Fix: Use correct repository method name&#10;        Notification notification = notificationRepository.findByIdAndUserId(notificationId, userId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Notification not found&quot;));&#10;&#10;        notification.setRead(true);&#10;        // Fix: use setReadAt instead of setReadDate&#10;        notification.setReadAt(LocalDateTime.now());&#10;        notificationRepository.save(notification);&#10;    }&#10;&#10;    public void markAllAsRead(Long userId) {&#10;        // Fix: Use correct repository method name&#10;        List&lt;Notification&gt; unreadNotifications = notificationRepository.findByUserIdAndReadFalse(userId);&#10;&#10;        for (Notification notification : unreadNotifications) {&#10;            notification.setRead(true);&#10;            // Fix: use setReadAt instead of setReadDate&#10;            notification.setReadAt(LocalDateTime.now());&#10;        }&#10;&#10;        notificationRepository.saveAll(unreadNotifications);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>